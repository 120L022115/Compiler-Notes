#### 7 运行存储分配

1. 为数据对象分配存储空间。
   对编译时刻能够确定的对象分配到静态空间。
   对运行时刻才能确定的对象分配到动态空间。

2. 低地址
   静态空间：静态代码、静态数据。
   动态空间：栈（活动记录和部分局部变量），堆（申请的变量）。
   高地址

3. 活动记录：过程/函数的每一次执行的数据。包括：

   1. 实参
   2. 返回值
   3. 控制链（动态链）：指向调用者的数据起始区指针（rsp）。
   4. 访问链（静态链）：按需选择，见后续。
   5. 保存的机器状态
   6. 局部数据
   7. 临时变量

4. 静态分配：只用静态分配BASIC/FORTRAN

   1. 条件：数组长度为常数、不允许过程递归调用、不允许动态建立数据实体
   2. 方法：
      1. 顺序分配法：按照出现顺序逐次分配存储空间
         1. 简单，但存在空间浪费。

      2. 层次分配法：按照定义的层次逐层分配，没有相互调用的过程（更低层次）之间可以共享内存空间（你用我不用，我用你不用）。

5. 动态-栈式分配

   1. 活动树和控制栈

      控制栈：活动记录1、1的数据区、活动记录2....

   2. 调用序列和返回序列

      1. 调用：调用者：计算实参、设置控制链为RSP、更新RSP；被调用者：保存机器状态（RIP返回地址）、初始化数据（可能在控制栈中设置数据区）；
      2. 返回：被调用者：设置返回值、恢复RSP、跳转到返回地址；调用者：使用返回值。

   3. 如果局部变量包含数组，则活动记录中包含数组首地址指针（指向数据区），在数据区才是完整的数组内容。

6. 嵌套深度

   1. 如果过程可以嵌套定义，定义的过程存在嵌套深度。
   2. 最外层的过程嵌套深度为1。

7. 访问链

   1. 一种简单实现
      1. 指向最新的直接嵌套定义对象指针，确保变量作用域。
      2. 建立访问链：
         1. 外层调用内层：只能是直接嵌套定义的，被调用者的访问链**指向**调用者。
         2. 本层调用本层：如递归调用，被调用者的访问链**直接复制**调用者的访问链。
         3. 内层调用外层：外层的父亲过程先定义了该函数，内层（可能嵌套了多层）后调用。被调用的函数的父亲就是目标访问链。因此两者隔了：（调用者层数 - 被调用者层数 + 1（父亲））层，也即**沿着访问链**跳跃这么多次就能访问到目标。
   2. DISPLAY表（嵌套层次显示表）
      1. 上述方法存在的问题：访问外层效率低。
      2. d[i]指向当前运行栈的最新建立的嵌套深度为i的活动记录（可能存在多个，但要最新的）。如果要访问访问链，只需要知道当前层级，和偏移量（$\Delta n+1$）即可。
      3. 原始的访问链字段存储旧的d[i]。

8. 符号表

   1. 含有基础信息、扩展信息（指针、内情向量）
   2. 基础信息包括：种属、类型、存储位置、长度、名称等等。
   3. 方法1：每个过程一个表。
      1. 形式
         1. 有一个根表，其嵌套层数为0。
         2. 每个表有个头，有个指向上一个表的指针，还有一个表的总长度（不含子表，只有本表的变量）
         3. 按变量定义出现顺序逐步分配内存，对过程有个指针指向下一个表。
         4. 每个变量有个偏移地址。
         5. 在翻译的过程中，有两个同步栈来存当前的表和当前表内的偏移。

      2. 函数
         1. mktable(previous_ptr)：创建一个新符号表，并设置header的父表指向。
         2. addwidth(table,width)：设定表的总长度（传入最终的偏移栈顶）
         3. enter(t,name,type,offset)：插入新变量表项。一般同时更改top(offsetstack)+=T.width。
         4. enterproc(table, name, newtable)

      3. 方案
         1. 变量声明语句：
            结束：查本层表，如有报错；否则插入表项enter, offset++;
         2. 过程声明语句：
            开始：查本层表，如有报错；否则mktable, table.push (new), offset.push(0)。
            结束：addwidth,pop,pop,插入表项enterproc
         3. 变量使用语句：查表，如有则将层号、offset作为中间地址的一部分生成，否则**查父表直到根**，如果没有则报错。
         4. 结构体的声明认为是一个特殊的过程，单独建立一个符号表。

   4. 方法2：一个大表+2个指针表。
      1. display表：同前，新增一个指针指向btab表。栈式结构，有入有出。
      2. btab表：只入不出。每个表项包含lastpar、last两个指针，指向nametab的下标，分别表示最后一个形参（形参也是一个符号变量！如果没有则为0）、最后一个符号（可能相同）。
      3. nametab：只入不出。每个表项就是一个符号表表项，但包括额外的link字段：指向同过程的上一个符号，如果是当前过程的第一个符号则为0。
      4. 在构建此表的过程中，即使存在嵌套过程，但在过程分析完成后，仍然能够找到上一个符号的偏移地址：display内过程出栈，栈顶指针指向的btab的last即是当前分析的最后一个符号（即该内过程的名字）。


