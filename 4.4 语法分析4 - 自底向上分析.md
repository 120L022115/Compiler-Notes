#### 4.4 语法分析4 - 自底向上分析

1. 最左规约：最右推导

2. 通用框架：移入归约分析

   用栈来存储当前句型，下推自动机。
   移入：入栈，归约：出栈，入栈。归约为开始符号即结束。
   移入输入符号，归约多个输入符号为非终结符。

3. 句柄：每次被归约的符号串

   | 句柄           | $\iff$                      | 最左直接短语   |
   | -------------- | --------------------------- | -------------- |
   | $\Uparrow$     |                             | $\Downarrow$   |
   | **在分析树中** | $\overset{and}{\leftarrow}$ | **产生式右部** |

   对于一个句子有的产生式用不上则不是句柄（直接短语）

4. 规范句型的活前缀：不会越过<u>句柄</u>$\left\{\begin{aligned}var \\var <ID>\\var <ID>, \\var \underline{<ID>,i}\\ \xcancel{var <ID> ;} \end{aligned} \right.$

5. 存在的问题：归约归约冲突，移入归约冲突。

6. 增广文法：添加一个新产生式$S'\to S$，保证以开始符号为左部的产生式只存在一条。
   也即：只存在一个接收状态$S'\to S·$。

7. ~(LR(0))~项目（自动机状态）：用"·"表示当前读头位置。

   1. 初始项目：$S'\to ·S$
   2. 接收项目：$S'\to S·$
   3. 移进项目：下一个为终结符：$S\to A·bBB$
   4. 待约项目：下一个为非终结符：$S\to Ab·BB$
   5. 归约项目：下一个为\$：$S\to AbBB·$
   6. 后继项目：在**同一产生式**中圆点位置只差一个符号的项目，后者是前者的后继项目。
   7. 等价项目："·"后为非终结符，则"·"在将非终结符展开后的项目是相互等价的。
   8. 等价项目集闭包： $\left\{\begin{aligned} S'\to·S,\\S\to·Abc,\\S\to·dBc,\\A\to·dAC\end{aligned} \right\} $

8. LR文法：从左扫描，最右推导
   $LR(0)\to SLR \to LR(1) \to LALR$
   都使用LR分析表，但构造的方法略有不同

9. LR分析表：循环栈顶状态直至接收或报错；令x为栈顶状态，a为输入符号。
   $while(1)\left\{\begin{aligned} ACT[x,a]=st \to push(t);next(a); \\ \begin{aligned} ACT[x,a]=rt \\ =r[A\to\beta]\end{aligned} \to \left\{\begin{aligned}  pop|\beta|个符号;\\(x=新栈顶)\\push(GOTO[x,A]);\\print(A\to\beta) \end{aligned}\right\}\\ ACT[s,a]=acc\to break; \\ else \to error \end{aligned}\right\}$

   |      | ACT  | -ION | GO   | -TO  |
   | ---- | ---- | ---- | ---- | ---- |
   | 状态 | a    | $    | A    | B    |
   | 0    | s3   | acc  | 1    | 2    |

   ACTION每个表项可以为：

   1. acc 表示接收
   2. sX：（移入符号并）将状态X压入栈
   3. rX：用第X个产生式规约：出栈右部所有的符号和对应的状态，进栈状态和左部。

   GOTO每个表项：归约出A转移到[x,A]状态。

10. LR(0)文法/分析/自动机：

    1. 状态：LR(0)项目集闭包（给其编个号）
    2. 转移："·"后下个符号，转移到所在项目集闭包
    3. 实现：
       CLOSURE(项目):计算闭包
       GOTO(项目,文法符号X):计算后继闭包
       构造分析表：对每个状态集，存在三种项目：移进、待约、归约。用i表示当前状态序号，$j_x$表示当前状态i相对于文法符号X的后继状态序号（$项目集_{j_X} = GOTO[i,X]$），k表示B的产生式编号，ACT/GO表示分析表。
       1. 移进a(点下一个符号)：$ACT[i,a]=j_a$
       2. 待约B(点下一个符号)：$GO[i,B]=j_B$
       3. 归约B(产生式左部)：
          $\left\{\begin{aligned}B=S' \Rightarrow ACT[i,\$]=acc\\else\Rightarrow for(a\in V_t\cup\{\$\})ACT[i,a]=r_k  \end{aligned}\right.$
          **设置一整行都为归约（不精准会出现问题，可能会同时有移进或多个归约）**
    4. 按以上方法没有冲突的文法称为LR(0)文法。

11. SLR分析：LR(0)只考虑了上文。使用FOLLOW集来判断下文。

    1. 冲突：在同一项目集中，不存在"·"的后续符号冲突（"·"后为非终结符则求FOLLOW集，所有的FOLLOW集和"·"后所有的终结符不相交）
    2. 构造表：归约部分改为：
       $\left\{\begin{aligned}B=S' \Rightarrow ACT[i,\$]=acc\\else\Rightarrow for(a\in \underline{FOLLOW(B)})ACT[i,a]=r_k  \end{aligned}\right.$
       不是一整行了，精准对应FOLLOW。但存在问题：FOLLOW集可能相交，这是因为FOLLOW集是所有情况的后继符号，而一个确定性文法在某种情况的后继符号一定是FOLLOW的子集，需要分情况讨论。

12. LR(1)分析（简写为LR）

    1. LR(1)项目：[LR(0)项目, 展望符]
    2. 展望符：项目的可能后继符号，在归约时使用。等价项目的推导时需要**重新计算**后继符号（自生的），其他情况直接继承父项目的展望符（继承的）。
    3. 在归约时，只有下一个符号时展望符时才可以进行归约。
       $\left\{\begin{aligned}B=S' \Rightarrow ACT[i,\$]=acc\\else\Rightarrow if(a=展望符)ACT[i,a]=r_k  \end{aligned}\right.$

13. LALR分析

    1. LR分析的状态数太多，减少状态数：对于核心产生式一样的不冲突状态进行合并。
       不冲突：产生式相同，**展望符**是子集关系或其他产生式未使用。
    2. 特点：推迟了错误的发现，最晚在下一个移入时才发现。（只修改了归约项目，对于不能归约的时候也归约了，但下一次移入必定不正确）
    3. 形式上与LR相同
    4. 大小与LR(0)/SLR相当
    5. 分析能力介于SLR和LR之间

14. 对二义性文法的分析

    1. 二义性文法一定不是LR文法。但可以增加消岐规则然后使用LR分析。
    2. 在自动机中，添加额外的边。
    3. 严格控制使用，稍有不慎会导致分析错误。

15. 错误处理

    1. 恐慌模式：从栈顶向下扫描，直至发现一个状态s存在GOTO(s,A)项（设其条件是归约出A），丢弃s+1到栈顶的所有状态。扫描输入串，直至发现FOLLOW(A)。假装将A归约成功，执行压栈GOTO(s,A)。
    2. 短语层次错误恢复：在非归约项的ACT表中的空项（报错项）添加不同的错误处理例程指针，针对当前的项目进行相应的处理。对于归约项目，可以直接归约（“延迟错误的发现”）。
