#### 8 代码优化

1. 基本块：将中间代码划分，控制流只能从第一条开始，在第一条结束或跳出。

   划分算法：

   1. 指令序列的第一个三地址指令是首指令
   2. 转移指令的目标指令是首指令
   3. 紧跟在转移指令后的指令是首指令

2. 流图：基本块+有向边

   有向边：块最后一条指令的下一条执行指令**可能**是下一个块的第一条指令（考虑各种转移）

3. 代码优化的分类

   1. 机器无关优化：针对中间代码
   2. 机器相关优化：针对目标代码
   3. 局部代码优化：单个基本块内优化
   4. 全局代码优化：多个基本块优化

4. 常用的优化方法

   1. 删除公共子表达式

      如果值被计算过了存到变量中，且后续**所有的控制流**中都没有对其赋值，那么可以直接使用该变量，无需重算。（注意数组以变量为下标的元素代表了所有元素的更改，因为不知道变量具体是哪个值）

   2. 删除无用代码

      复制传播：尽可能地用赋值对象，而不是被赋值的。

      常量传播：赋值对象是常量。

   3. 代码移动（全局优化）

      循环不变计算挪到循环外部。

   4. 强度削弱

      用较快的计算代替较慢的计算：移位代替2的指数乘/除法，加法代替2倍，乘法代替平方，多项式求递推表达式。

      每次循环用局部变量加法代替对循环值i的乘法。
      i++; t=i*4; $\Rightarrow$ t+=4; 

   5. 删除归纳变量

      增减步调一致的变量，且仅被用于比较时。删除其中一个。

5. 实现优化方法

6. 基本块的DAG（有向无环图）
   对基本块内部的每一条指令，从上到下构造一个图。每个结点有一个定值变量表。

   1. 生成叶结点：来自于基本块外部赋值的变量有一个结点，叫做$XX_0$。
   2. 对每一条三地址语句，A = B # C
      1. 如果图中不存在B或C的运算，则新建结点：运算符是结点，且定值变量表是被赋值的变量，孩子是参与运算的变量。
      2. 如果存在，则删掉已知存在的结点中定值变量表对应的变量，并新建结点。保证图中定值变量表只能保留最新的被赋值变量。
      3. 如果数组元素的有赋值，则需要杀死所有已经建立且值依赖于该数组（任意元素）的结点，这将导致该结点后续不能够被改变，如果需要改变定制变量表，则要重新建立结点。（阻止其成为公共子表达式，因为可能被改变）
      4. 跳转指令的表示：比较运算符结点一大一小。
      5. 如果是常量运算，需要在定值变量旁边标注其运算结果值。
   3. 对于已知的非活跃变量（其值在后续基本块中都不会被使用），且所在的定值变量表在图中为根节点，则在图中删掉。不断迭代直至符合（删掉一个可能孩子也满足了）。
   4. DAG构造完成后，对基本块进行重组：对具有多个定值变量的结点，如果都是活跃变量，需要引入复制语句。

7. 数据流分析
   把程序点和有关数据关联起来。

   1. 程序点：每一条语句**前**的位置都是一个程序点，最后一条语句后也是程序点。
   2. 语句传递函数：相邻程序点的数据流之间的关系
      1. IN(s)：语句s前程序点的数据流值
      2. OUT(s)：语句s后程序点的数据流值
      3. 显然IN(s')=OUT(s)，s'为紧跟在s后的语句
      4. 前向传递函数：OUT = f ( IN )
      5. 逆向传递函数：IN = f ( OUT )
   3. 基本块传递函数：基本块前后的数据流关系
      1. 前向数据流： $OUT=f_B(IN)=f_n·f_{n-1}· ·· ·f_1(IN)$
      2. 逆向数据流
      3. 基本块的数据流值：
         1. IN(B) = IN(s1)
         2. OUT(B) = OUT(sn)

8. 数据流分析-到达定值分析（正向）

   1. 定值：每一个（条件）赋值语句都是一次定值。给其起一个标号。
   2. 到达定值：每出现一个新定值都将杀死前一个同变量的定值。对某一条语句，定值可能能到达该语句（存在分支语句），则成为到达定值。
   3. 用途：
      1. 循环不变计算的检测：对某条语句，其所需的变量的所有定值都在循环外面。
      2. 常量传播：对某个变量的一次引用，只有一个定值能够到达，且这是个常量，则可以直接替换。
      3. 检测变量未经定义就被引用。
   4. 传递函数：OUT[B] = gen$\cup$(x-kill)
      gen：该语句生成的定值
      kill：该语句杀死的定值
      x：IN[B]（正向数据流）
      B$\ne$ENTRY
   5. OUT[ENTRY] = $\empty$
      IN[B] = $\cup_{P是B的前驱}$OUT[P]
   6. 引用定值链（UD链）：是一个列表，针对一个变量引用，到达该引用的所有该变量的定值都在该列表中。
      如果在基本块内有定值则只有最后一次定值在列表中，因为其杀死了其他定值，否则可能有多个，因为可能存在分支语句。
   7. 计算到达定值的算法：不断迭代，直到不再变化。行头：基本块；列头：OUT\IN；表项是01串，每一位表示一个定值能否到达。

9. 数据流分析-活跃变量分析（逆向）

   1. 活跃变量：如果在某程序点定值的变量后续某条路径中会引用，则称变量在该点为活跃的。
   2. 用途：
      1. 删除无用赋值：不活跃的变量无需再赋值。
      2. 为基本块分配寄存器：需要知道谁之后活跃、谁不活跃。
   3. 传递函数：IN[B] = use $\cup$ (x - def)
      use：在基本块中**引用前没被定值**且被引用：使用了前面的定值
      def：在基本块中定值且**定值前没被引用**：新变量
      x：OUT[B]
      B$\ne$EXIT
   4. IN[EXIT] = $\empty$
      OUT[B] = $\cup_{S是B的后继} IN[S]$ 
   5. 定值引用链（DU链）：是一个列表，针对一个定值，能够到达的引用集合。
      例：在基本块中有两个定值，之间的所有引用的集合构成第一个定值的定值引用链。
      在基本块中最后一个定值，则定值后的所有引用，以及OUT[B]中的该变量的所有引用构成该定值的DU链。
   6. 计算方法：迭代。行头是基本块，列头是OUT/IN，表项是变量名。

10. 数据流分析-可用表达式分析（正向）

    1. 可用表达式：从ENTRY到程序点p的每条路径都计算了x op y，且没有再次对x、y定值，则x op y在该点是可用的。x op y之前已经被计算过，且没有更新，无需重新计算。
    2. 用途：
       1. 消除全局公共子表达式
       2. 进行复制传播：形如x=y; z=x+1 => 变量的直接替换 z=y+1;，前提：所有路径必须都有x=y;才行。

    3. 传递函数：OUT[B] = e_gen $\cup$ (x - e_kill)
       e_gen：基本块中生成的可用表达式。
       e_kill：基本块中杀死的可用表达式（无论当前有没有生成，都从全集U中取出）。
       U：所有的表达式。
    4. 生成算法：任何赋值语句的右部都产生一个新的表达式。
       杀死算法：x有新定值，则杀死所有含x的表达式。
    5. OUT[ENTRY] = $\empty$
       $\star$$\star$$\star$$\star$$\star$$\star$：IN[B] = $\cap_{P是B的前驱}OUT[P]$
       前面都是并，唯独这个是交（后面也是），因为要求所有路径都有才行。
    6. 计算方法：**先初始化所有块的OUT为U**，再进行迭代。

11. 数据流分析-支配节点、循环分析（正向）

    1. 支配结点：从ENTRY到n的每条路径都经过d，则d支配n。记d dom n
       每个结点都支配它自己。在流图中，每个结点为一个基本块。
    2. 支配结点树：父节点支配子树的所有节点。
    3. 传递函数： OUT[B] = IN[B] $\cup$ { B } （B$\ne$ENTRY）
       IN[B] = $\cap_{P是B的前驱}OUT[P]$
       OUT[ENTRY] = {ENTRY}
    4. 计算方法：**先初始化每个块的OUT为结点的全集N**，再进行迭代。
    5. 回边：在流图中存在直接的有向边，但被指向的却支配指向的，该边称为回边。
    6. 自然循环：唯一进入循环的结点（不能中间进入）。每一条回边都存在一个自然循环：$n \to d$，首结点d，循环内结点为**从自身开始不经过d能到达n**的结点。
       如果首结点不同，则要么不相交、要么嵌套在内部，只算最内循环。
       如果首结点相同，要合并为一个自然循环。

12. 小结

![8](E:\OneDrive - stu.hit.edu.cn\学习\编译系统\截图\8.png)

![8.1](E:\OneDrive - stu.hit.edu.cn\学习\编译系统\截图\8.1.png)
